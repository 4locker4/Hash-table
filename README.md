# Исследования оптимизаций кода на примере хеш-таблици.

## 1. Аннотация

Цели данной работы:
- Знакомство с профилировочными программами.
- Аппаратно зависивисимая оптимизация кода хеш-таблици.

В работе были выполнены такие оптимизации функций поиска, как:

1.  Оптимизация функций с помощью AVX/AVX2 инструкций.  [Подробнее здесь](#avx-strcmp-optimisation)
2.  Оптимизация с использованием ассемблерной вставки.  [Подробнее здесь](#hash-function-optimisation).
3.  Оптимизация при помощи написания функции на языке ассемблер. \
 [Подробнее здесь](#asm-strcmp-optimisation)

Профилировщики, с помощью которых собирались данные: ***kcashegrind***, ***perf***

В результате прирост скорости выполнения программы составил:

| Флаг | Без оптимизаций | С оптимизациями | Прирост |
|------|-----------------|-----------------|---------|
|-O0   | 64.90c          | 24.88c          | 260%    |
|-O3   | 30.72c          | 20.90c          | 147%    |

### | Характеристики CPU

  - **Info**: 12-core (4-mt/8-st) model: 13th Gen Intel Core i5-1340P 
  
 -  **bits**: 64 type: MST AMCP
    arch: Raptor Lake rev: 2 cache: L1: 1.1 MiB L2: 9 MiB L3: 12 MiB


  - **Speed** (MHz): avg: 713 high: 1500 min/max: 400/4600:3400 
  
  - **Flags**: avx avx2 ht lm nx pae sse sse2 sse3 sse4_1 sse4_2 ssse3 vmx

## 2. Введение

Одним из наиболее эффективных способов хранения большого количества информации являются хеш-таблицы.

> 

    Хеш-таблица — это структура данных, в которой все элементы хранятся в виде пары ключ-значение, где:

        ключ — уникальное число, которое используется для индексации значений;
        значение — данные, которые с этим ключом связаны. 
    
    (с) codechick.io [1]

### | Преимущества хеш-таблиц

При правильном подборе хеширующей функции и размера хеш-таблицы средняя скорость доступа к данным составляет O(1). Но при этом не гарантируется, что время выполнения отдельной операции мало́.

### | Проблемы

Однако, на практике такое случается редко. Не всегда есть возможность подобрать такой тип, размер хеш-таблици и хеш-функцию, чтобы для каждого уникального элемента выделялся свой ключ и свое место. 

Случай, когда хеш-функция генерирует один ключ для разных элементов данных называется **коллизией**.

Существует несколько способов борьбы с колллизиями:

- *Метод цепочек*. Суть метода заключается в том, что если хеш-функция выделяет один ключ сразу нескольким элементам, то храниться они будут в одном и том же индексе, но уже с помощью двусвязного списка. 
- *Открытая адресация* В отличие от метода цепочек, в открытой адресации несколько элементов в одной ячейке храниться не могут. Суть этого метода заключается в том, что каждая ячейка либо содержит единственный ключ, либо ```NULL```. 

\* Существует несколько видов открытых адресаций. Подробное их описание представленно [здесь](https://codechick.io/tutorials/dsa/dsa-hash-table).

> [!WARNING]
>В данной работе намеренно подобран такой размер хеш-таблицы, что среднее количество коллизий на каждый ключ примерно равно 15. Данное допущение обусловленно учебными целями, для того, чтобы аппаратно-зависимые оптимизации были более эффективными.
> 
> В данной работе также не ставится ограничений на безопасность хеш-таблицы, для того, чтобы не сужать круг выбора хеш-функций. 

## 3. Методика

Для проведения оптимизаций написана программа для построения хэш-таблицы. Коллизии в данной хеш-функции решаются методом цепочек.

Далее к хеш-таблице требуется подобрать хэширующую функцию и размер так, чтобы load factor (частное от деления количества вставленных элементов на размер внутреннего массива) и количество коллизий на один ключ были примерно равены 15.

В ходе работы будут производиться профилирования, обработка результатов профиля, оптимизация наиболее нагруженной функци и замер прироста эффективности. Процесс будет повторяться до тех пор, пока он полезен для обучения. 

## 4. Результаты

Для теста хеш-таблицы был взят текст Льва Толского "Война и мир", содержащий примерно 680 тысяч слов. Однако уникальных примерно 15 тысяч, если не брать в рассчет регистр. Однако данная хеш-таблицы - регистро-зависимая. Поэтому размер хеш-таблицы примем равным 1000.

Далее перейдем к подбору хеш-функции.

В данной работе были рассмотрены:

### | 1. Хеш-функция, вычисляющая длинну слова

<details>

<summary> Разверните, чтобы посмотреть код </summary>

```
static inline unsigned int LenghtCalc (const char* elem)
{
    unsigned int hash = 0;

    while (*elem != '\0')
    {
        hash++;
        elem++;
    }

    return hash;
}
```
</details>

<img src="OptimisationsImgs/LenghtsDiog.png" width="1000">

Среднее количество коллизий на ключ = 107. Очевидно, что масштабирование хеш-таблицы, которая использует данную хеш-функцию, не принесет значимых результатов, так как длина слова редко превышает 25 символов.

### | Хеш-функция, вычисляющая сумму ASCII символов слова

<details>

<summary> Разверните, чтобы посмотреть код </summary>

```
static inline unsigned int AsciiSumCalc (const char* elem)
{
    unsigned int hash = 0;

    while (*elem != '\0')
    {
        hash += *elem;
        elem++;
    }

    return hash;
}
```
</details>

<img src="OptimisationsImgs/ASCIIhash.png" width="1000">

Видно, что дисперсия в данной функции слишком велика, из-за чего время поиска различных элементов может сильно варьироваться.

### | DJB2

<details>

<summary> Разверните, чтобы посмотреть код </summary>

```
static inline unsigned int DJB2Hash (const char* elem)
{
    unsigned int hash = 0;

    while (*elem)
    {
        hash = ((hash << 5) + hash) + (*elem);

        elem++;
    }
    
    return hash;
}
```
</details>

<img src="OptimisationsImgs/DJB2Collisions.png" width="1000">

В данной функции распределение элементов уже значительно лучше. Попробуем увеличить размер таблицы.

<img src="OptimisationsImgs/DJB2Updated.png" width="1000">

Видно, что при увеличении хеш-таблицы до 3000 ячеек, растет дисперсия. При дальнейшем масштабировании дисперсия будет только увеличиваться.

### | JENKINS

<details>

<summary> Разверните, чтобы посмотреть код </summary>

```
static inline unsigned int JENKINS (const char* elem)
{
    unsigned int hash = 0;

    while (*elem != '\0')
    {
        hash += (char) *elem++;
        hash += (hash << 10);
        hash ^= (hash >> 6);
    }

    hash += (hash << 3);
    hash ^= (hash >> 11);
    hash += (hash << 15);

    return hash;
}
```
</details>

<img src="OptimisationsImgs/JENKINSHash.png" width="1000">

Данная хеш-функция показывает хорошее распределение. Попробуем увеличить размер хеш-таблицы.

<img src="OptimisationsImgs/JENKINSUpdate.png" width="1000">

JENKINS - подходящая хеш-функция. Продолжим исследование дальше.

### | Adler-32

<details>

<summary> Разверните, чтобы посмотреть код </summary>

```
static inline unsigned int Adler_32 (const char* elem)
{
    uint32_t s1 = 1;
    uint32_t s2 = 0;
  
    while(*elem != '\0')
    {
        s1 = ( s1 + *( elem++ ) ) % 65521;
        s2 = ( s2 + s1 ) % 65521;
    }
    return ( s2 << 16 ) + s1;
}
```
</details>

<img src="OptimisationsImgs/Adler1000.png" width="1000">

На 1000 ячеек у Adler_32 высокая дисперсия. При увеличении до 5000 ячеек дисперсия уменьшается.

<img src="OptimisationsImgs/Adler5000.png" width="1000">

Проведем проверку для 500 элементов. 

<img src="OptimisationsImgs/Adler500.png" width="1000">

Видно, что дисперсия растет с уменьшением размера хеш-таблици.

Данная функция также может быть применена в данной работе.

### | CRC-32


<details>

<summary> Разверните, чтобы посмотреть код </summary>

```
static inline unsigned int CRC32 (const char* elem)
{
    unsigned int hash = 0xFFFFFFFF;

    while (*elem != '\0')
    {
        size_t byte = (char) *elem++;
        hash = (hash >> 8) ^ crc32_table[(hash ^ byte) & 0xFF];
    }

    return hash ^ 0xFFFFFFFF;
}
```
</details>

Данная функция показывает себя лучше Adler-32 на меньших размерах хеш-таблицы. Далее приведены диаграммы.


<details>

<summary> 1. CRC32, размер таблицы 500 элементов.</summary>

<img src="OptimisationsImgs/CRC32500.png" width="1000">

</details>

<details>

<summary> 2. CRC32, размер таблицы 1000 элементов.</summary>

<img src="OptimisationsImgs/CRC32.png" width="1000">

</details>

<details>

<summary> 3. CRC32, размер таблицы 5000 элементов.</summary>

<img src="OptimisationsImgs/CRC325000.png" width="1000">

</details>

### | Итог

JENKINS, Adler-32 и CRC-32 - наиболее подходящие хеш-функции для данной работы. 

Однако у CRC-32 есть большое преимущество перед остальными двумя. Для CRC-32 существует отдельная assembler команда. CRC-32 лучше подходит под аппаратное оснащение компьютера, на котором выполняется исследование. Поэтому в хеш-таблице будет использована CRC-32.

### | Начало оптимизаций профилировщиками

Для сбора данных профилирующими программами функция поиска элементов хеш-таблицы будет вызвана 1 000 000 000 раз.

При первом запуске программы профилировщик ***kcachegrind*** показал результаты:

<img src="OptimisationsImgs/GraphBeforOpt.png" width="1000">

\- Результаты из kcashegrind

<img src="PerfProfiler/PerfStart.png" width="1000">

\- Результаты из perf

| Номер измерения | Время работы |
|-----------------|--------------|
|1                | 64.7c        |
|2                | 64.0c        |
|3                | 64.3c        |
|4                | 64.1c        |
|5                | 64.3c        |


|Итог:            | 64.28c       |
|-----------------|--------------|

Время работы программы составило **64.28** секунды.

Первая функция для оптимизации - хеш-функция.

### Hash function optimisation

Как отмечалось при выборе хеш-функции, CRC-32 имеет специальную assembler функцию. Поэтому будет переписана на встроенноем assembler.

```
    __asm__(
        ".intel_syntax noprefix         \n\t"
        "                               \n\t"
        "xor rax, rax                   \n\t"
        "                               \n\t"
        "mov eax, 0xffffffff            \n\t"
        "                               \n\t"
        "jmp 0f                         \n\t"
        "                               \n\t"
        "1:                             \n\t"
        "                               \n\t"
        "crc32 eax, byte ptr [%[elem]]  \n\t"
        "inc %[elem]                    \n\t"
        "                               \n\t"
        "0:                             \n\t"
        "                               \n\t"
        "cmp byte ptr [%[elem]], 0      \n\t"
        "                               \n\t"
        "ja 1b                          \n\t"
        "mov %[hash], eax               \n\t"
        "                               \n\t"
        :[hash] "=m"(hash)
        :[elem] "d"(elem)
        :"%rax");
```

\- оптимизированная CRC-32 хеш-функция.

Произведем профилирование повторно.

<details>

<summary> Граф профилирования: </summary>

<img src="OptimisationsImgs/crcGraphOpt.png" width="1000">

</details>

<details>

<summary> Данные kcachegrind: </summary>

<img src="OptimisationsImgs/crc32Opt.png" width="1000">

</details>

<details>

<summary> Данные perf: </summary>

<img src="PerfProfiler/perfCrcOpt.png" width="1000">

Посколько perf не видит некоторой функции, будем ориентироваться на данные из kcashegrind.

</details>

| Номер измерения | Время работы |
|-----------------|--------------|
|1                | 29.5c        |
|2                | 30.6c        |
|3                | 30.8c        |
|4                | 30.2c        |
|5                | 30.4c        |

|Итог: | 30.5c  |
|------|--------|


Новое время выполнения программы составило 30.5 секунд
### AVX strcmp optimisation

Из данных kcachegrind, полученных после оптимизации хеш-функции, видно, что strcmp () занимает 26.45%.

При выборе хеш-функции можно было заметить, что длина одного слова в тексте не превосходит 17 букв. Следовательно, strcmp () не требуется обрабатывать строки длины более 17. Поэтому оптимизацию можно построить на avx/avx2 инструкциях процессора.

Полученный код:

```
bool avx_strcmp (list_elem_t * first_str, list_elem_t second_str)
{
    my_assert (first_str && second_str);

    __m256i __first_str  = _mm256_loadu_si256 (&first_str->list_elem_opt);    
    __m256i __second_str = _mm256_loadu_si256 (&second_str->list_elem_opt);
    
    return ~(_mm256_movemask_epi8 (_mm256_cmpeq_epi8 (__first_str, __second_str)));
}
```
\- Оптимизация strcmp ()

Произведем профилирование повторно.

<details>

<summary> Граф профилирования: </summary>

<img src="OptimisationsImgs/StrcmpAvxOnlyOpt.png" width="1000">


</details>

<details>

<summary> Данные kcachegrind: </summary>

<img src="OptimisationsImgs/AvxOptOnly.png" width="1000">

</details>

<details>

<summary> Данные perf: </summary>

<img src="PerfProfiler/AvxStrcmp.png" width="1000">

</details>

| Номер измерения | Время работы |
|-----------------|--------------|
|1                | 33.6c        |
|2                | 34.1c        |
|3                | 34.1c        |
|4                | 34.0c        |
|5                | 33.9c        |

|Итог: | 33.94c |
|------|--------|

Как мы можем видеть, время выполнения программы увеличилось. Следовательно, оптимизация прошла безуспешно.

Попробуем написать strcmp () на языке assembler с использованием ymm регистров.

### ASM strcmp optimisation

```
section .text

global asm_avx_strcmp

asm_avx_strcmp:
        push rbp
        mov rbp, rsp

        vmovdqu ymm1, [rdi]
        vpcmpeqb ymm0, ymm1, [rsi]
        vpmovmskb rax, ymm0

        xor rax, 0xffffffff

        mov rsp, rbp
        pop rbp

        ret
```
\- Код strcmp () на языке assembler с использованием ymm регистров

Произведем профилирование повторно.

<details>

<summary> Граф профилирования </summary>

<img src="OptimisationsImgs/AsmAvxStrcmpOpt.png" width="1000">


</details>

<details>

<summary> Данные kcachegrind </summary>

<img src="OptimisationsImgs/AsmAvxStrcmpOptNotGraph.png" width="1000">

</details>

<details>

<summary> Данные perf </summary>

<img src="PerfProfiler/PerfAsmAvx.png" width="1000">

</details>

| Номер измерения | Время работы |
|-----------------|--------------|
|1                | 24.6c        |
|2                | 24.9c        |
|3                | 25.2c        |
|4                | 24.9c        |
|5                | 24.8c        |

|Итог: | 24.88с |
|------|--------|


Время выполнения теста уменьшилось, в отличие от оптимизации через AVX инструкции.

## 5. Выводы
 
 Дальнейшие оптимизации не дадут значительного прироста производительности и не дают полезной нагрузки для процесса обучения. 

По итогам исследования было проведено знакомство с профилировочными программами perf и kcachegrind. Проведены аппаратно зависимые оптимизации хеш-таблицы, результаты которых представлены в таблице:


| Флаг | Без оптимизаций | С оптимизациями | Прирост |
|------|-----------------|-----------------|---------|
|-O0   | 64.90c          | 24.88c          | 260%    |
|-O3   | 30.72c          | 20.90c          | 147%    |

## 6. Источники информации

[1]. Хеш-таблицы // codechick.io URL: https://codechick.io/tutorials/dsa/dsa-hash-table (дата обращения: 28.04.2025).

[2]. Хеш-функция // ru.wikipedia.org URL: https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F (дата обращения: 01.05.2025)