# Исследования оптимизаций кода на примере хеш-таблици.

## 1. Аннотация

Цели данной работы:
- Знакомство с профилировочными программами.
- Аппаратно зависивисимая оптимизация кода хеш-таблици.

В работе были выполнены такие оптимизации наиболее частно вызываемых функций поиска, как:

1.  Оптимизация функций с помощью AVX/AVX2 инструкций. Подробнее здесь [ссылка]
2.  Оптимизация с использованием ассемблерной вставки. Подробнее здесь [ссылка]
3.  Оптимизация при помощи написания функции на языке ассемблер.   
Подробнее здесь [ссылка]

Профилировщики, с помощью которых собирались данные: ***kcashegrind***, ***perf***

В результате прирост скорости выполнения программы составил:

| С флагом оптимизации | Прирост |
|----------------------|---------|
|-O0                   | XXX%    |
|-O3                   | XXX%    |

### Характеристики CPU

  - **Info**: 12-core (4-mt/8-st) model: 13th Gen Intel Core i5-1340P 
  
 -  **bits**: 64 type: MST AMCP
    arch: Raptor Lake rev: 2 cache: L1: 1.1 MiB L2: 9 MiB L3: 12 MiB


  - **Speed** (MHz): avg: 713 high: 1500 min/max: 400/4600:3400 
  
  - **Flags**: avx avx2 ht lm nx pae sse sse2 sse3 sse4_1 sse4_2 ssse3 vmx

## 2. Введение

Одним из наиболее эффективных способов хранения большого количества информации являются хеш-таблицы.

> 

    Хеш-таблица — это структура данных, в которой все элементы хранятся в виде пары ключ-значение, где:

        ключ — уникальное число, которое используется для индексации значений;
        значение — данные, которые с этим ключом связаны. 
    
    (с) codechick.io [1] (https://codechick.io/tutorials/dsa/dsa-hash-table)

### |Преимущества хеш-таблиц

При правильном подборе хеширующей функции и размера хеш-таблицы средняя скорость доступа к данным составляет O(1). Но при этом не гарантируется, что время выполнения отдельной операции мало́.

### |Проблемы

Однако, на практике такое случается редко. Не всегда есть возможность подобрать такой тип и размер хеш-таблици и хеш-функцию, чтобы для каждого уникального элемента выделялся свой ключ и свое место. 

Случай, когда хеш-функция генерирует один ключ для разных элементов данных называется **коллизией**.

Существует несколько способов борьбы с колллизиями:

- *Метод цепочек*. Суть метода заключается в том, что если хеш-функция выделяет один ключ сразу нескольким элементам, то храниться они будут в одном и том же индексе, но уже с помощью двусвязного списка. 
- *Открытая адресация* В отличие от метода цепочек, в открытой адресации несколько элементов в одной ячейке храниться не могут. Суть этого метода заключается в том, что каждая ячейка либо содержит единственный ключ, либо ```NULL```. 

\* Существует несколько видов открытых адресаций. Подробное их описание представленно в приложении.

> [!WARNING]
>В данной работе намеренно подобран такой размер хеш-таблицы, что среднее количество коллизий на каждый ключ не может быть меньше 20. Данное допущение обусловленно учебными целями, для того, чтобы аппаратно-зависимые оптимизации были более эффективными.
> 
> В данной работе также не ставится ограничений на безопасность хеш-таблицы, для того, чтобы не сужать круг выбора хеш-функций. 

## 3. Методика

Для проведения оптимизаций написана программа для построения хэш-таблицы размером 1500 ключей.Далее преведен первоначальный вариант хэш-функции. 

```
    size_t hash = 0;

    while (isalpha (*pointer_to_data))
    {
        hash = ((hash << 5) + hash) ^ (*pointer_to_data);

        pointer_to_data++;
    }
    
    return hash % HASH_TABLE_SIZE;
```
Число коллизий приведено ниже:

%график числа коллизий%

В выбранной хэш-таблице используется метод цепочек для решения проблемы коллизий. 

В ходе работы будут производиться профилирования, обработка результатов профиля, оптимизация наиболее нагруженной функци и замер прироста эффективности. Процесс будет повторяться до тех пор, пока данный процесс полезен для обучения. 

## 4. Результаты

При первом запуске программы профилировщик ***kcachegrind*** показал результаты:

<img src="Hash-table/OptimisationsImgs/GraphBeforOpt.png" width="500">